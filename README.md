# LazScope
FPC/Lazarus serial oscilloscope
A simple oscilloscope project which reads ADC data buffers from an Arduino Uno (can be adapted for other AVR controllers) via a serial connection.  This data gets displayed on a PC screen via a FPC/Lazarus GUI.

## Firmware
The ADC prescaler gets configured via the GUI to a value in the range 2 ... 128.  This prescaler divides the controller clock which drives the ADC. For example the Arduino Uno runs at 16 MHz, resulting in a sample acquisition time of around 1.6 to 100 microseconds. Note that the atmega328p datasheet recommends a limit of 200 kHz clock to the ADC (about 65 microseconds acquisition time) to achieve maximum accuracy.  A prescaler of 64 is slightly beyond the specification, but still gives excellent visual performance, even a prescaler of 32 looks visually OK.

The firmware implements elementary trigger functionality.  Either a rising or falling slope with a threshold value can be selected.  The trigger logic takes a significant amount of time relative to the sample time, hence the decision to only trigger at the start.  This means that the interval between the 1st and 2nd data point may be slightly longer than subsequent intervals due to this.

The ADC produces 10 bit results, however to reduce data storage space only the upper 8 bits of the ADC result is stored.

Multiple ADC channels can be selected.  The firmware will then cycle the multiplexer through the channels in fixed sequence.

The baud rate defaults to 115200, but can be changed by defining BAUD, e.g. via command line: _-dBAUD=38400_

### Supported controllers
The code is factored such that similar controllers such as attiny44/84 or attiny25/85 should also work (but is untested).
The firmware was tested on atmega328p, attiny45 and attiny24. Note that on low memory devices (attiny2x) only a few ADC samples can be collected per frame.

### Square wave generator
A square wave signal of 500 Hz is generated by the firmware. Very handy if one has a need to measure a signal in a hurry.

Controller | Square wave pin
---------- | ---------------
atmega328p | PD3
attinyx4 | PA7
attinyx5 | PB0

## Software
The GUI consist of a display thread (main thread) and a serial thread to handle asynchronous communication with the firmware.  The general communication protocol is based on a request/response model, with the main thread sending requests to the serial thread, which dispatches a single message and wait for a response.  If the request doesn't return data, the command itself is echoed back.  When a user selects an option, the main thread will post a message to a command queue in the serial thread.  If the serial thread receives a data packet it is stored in raw format in a temporary buffer in the serial thread.  A message is posted to the main form to flag data availability.  The main thread will then unpack the data, extract the time for the data packet and perform a checksum test to detect data consistency errors.

A reticule ("crosshair") tool is available which will snap to the nearest data point and display its coordinates.  Activate this by pressing the Alt button while moving the mouse cursor.

## Examples
Some signals were generated on a signal generator similar to this one (https://scienceprog.com/avr-dds-signal-generator-v20/)

### 50 Hz sine wave + 500 Hz square wave sampled at x32 prescaler
A decent quality trace of the two signals.
![](images/50Hz_sine_500Hz_squarex32.png)

### 50 Hz sine wave + 500 Hz square wave sampled at x8 prescaler
A poor quality trace caused by to high a sampling frequency. At too high sampling frequencies the ADC charge capacitor cannot be fully charged/discharged between sample cycles, leading to smearing of samples.  In this case the alternating sampling caused channel A0 to affect A1's reading and visa versa.
![](images/50Hz_sine_500Hz_squarex8.png)

